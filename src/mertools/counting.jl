
"""
    build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}) where {M<:AbstractMer}

Build a sorted list (vector) of kmer counts (MerFreq), serially and in memory.

This function is a serial and in memory `MerFreq` list builder that can build a
kmer count from a PairedReads datastore on it own (if you have memory and time),
but it is also intended to be composed into other multi-process or multi-threaded
kmer counting strategies.

This method estimates roughly how many kmers will be generated by the reads
specified by `range` in the dataset. It then pre-allocates an array to contain
them. It then collects the kmers, sorts, them, and then collapses them into a
list of counts sorted by the kmer.
"""
function build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}) where {M<:AbstractMer}
    max_read_size = maxseqlen(ReadDatastores.datastore(sbuf))
    chunk_mers = Vector{M}(undef, length(range) * (max_read_size - BioSequences.ksize(M) + 1))
    wi = firstindex(chunk_mers)
    read_sequence = LongDNASeq()
    @inbounds for i in range
        for mer in each(M, load_sequence!(sbuf, i, read_sequence))
            chunk_mers[wi] = canonical(mer)
            wi = wi + 1
        end
    end
    resize!(chunk_mers, wi - 1)
    return collapse_into_freqs(chunk_mers)
end

"""
    build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int) where {M<:AbstractMer}

Build a sorted list (vector) of kmer counts (MerFreq), serially and in memory.

This function is a serial and in memory `MerFreq` list builder that can build a
kmer count from a PairedReads datastore on it own (if you have memory and time),
but it is also intended to be composed into other multi-process or multi-threaded
kmer counting strategies.

This method pre-allocates space for `chunk_size` kmers, and iterates over kmers
in the reads in the dataset specified by `range` until the buffer is filled.
The mers are then collapsed into a list of counts, sorted by the kmer.
This list is then merged into another output list.
This process repeats for many chunks of kmers, building up the output list.

This method is useful for situations where you don't want (or have the space) to
allocate a buffer to collect all the kmers in the dataset all in one go.
"""
function build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int) where {M<:AbstractMer}
    chunk_mers = Vector{M}(undef, chunk_size)
    chunk_freqs = Vector{MerFreq{M}}()
    sizehint!(chunk_freqs, chunk_size)
    output = Vector{MerFreq{M}}()
    
    read = first(range)
    lastread = last(range)
    read_sequence = LongDNASeq()
    
    mergen = each(M, load_sequence!(sbuf, read, read_sequence))
    mernext = iterate(mergen)
    chunkfill = 1
    
    @inbounds while read <= lastread
        #Â Fill the `chunk_mers` buffer with a load of kmers.
        while mernext !== nothing && chunkfill <= chunk_size
            chunk_mers[chunkfill] = canonical(mernext[1])
            chunkfill = chunkfill + 1
            mernext = iterate(mergen, mernext[2])
        end
        if isnothing(mernext) # Current read is consumed.
            read = read + 1
            if read <= lastread # There are more reads to come.
                mergen = each(M, load_sequence!(sbuf, read, read_sequence))
                mernext = iterate(mergen)
            else # There are no more reads to come.
                resize!(chunk_mers, chunkfill - 1)
                collapse_into_freqs!(chunk_mers, chunk_freqs)
                merge_into_sorted!(output, chunk_freqs)
                return output
            end
        end
        if chunkfill > chunk_size # The buffer is full, time to merge into output.
            collapse_into_freqs!(chunk_mers, chunk_freqs)
            merge_into_sorted!(output, chunk_freqs)
            chunkfill = 1
        end
    end
end








#=
function build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int = 1000000) where {M<:AbstractMer}
    chunk_mers = Vector{M}()
    chunk_freqs = Vector{MerFreq{M}}()
    sizehint!(chunk_mers, chunk_size)
    output = Vector{MerFreq{M}}()
    
    read = first(range)
    lastread = last(range)
    read_sequence = LongDNASeq()
    
    while read <= lastread
        while read <= lastread && length(chunk_mers) < chunk_size
            # Collect mers into a batch
            for mer in each(M, load_sequence!(sbuf, read, read_sequence))
                push!(chunk_mers, canonical(mer))
            end
            read = read + 1
        end
        # Sort and collapse the batch into a MerList
        collapse_into_freqs!(chunk_mers, chunk_freqs)
        merge_into_sorted!(output, chunk_freqs)
        empty!(chunk_mers)
    end
    return output
end

function build_freq_list2(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int = 1000000) where {M<:AbstractMer}
    chunk_freqs = Vector{MerFreq{M}}()
    sizehint!(chunk_freqs, chunk_size)
    output = Vector{MerFreq{M}}()
    
    read = first(range)
    lastread = last(range)
    read_sequence = LongDNASeq()
    
    while read <= lastread
        while read <= lastread && length(chunk_freqs) < chunk_size
            # Collect mers into a batch
            for mer in each(M, load_sequence!(sbuf, read, read_sequence))
                push!(chunk_freqs, MerFreq{M}(canonical(mer), 0x01))
            end
            read = read + 1
        end
        # Sort and collapse the batch of mers.
        collapse!(chunk_freqs)
        merge_into_sorted!(output, chunk_freqs)
        empty!(chunk_freqs)
    end
    return output
end

function build_freq_list3(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int) where {M<:AbstractMer}
    @info chunk_size
    
    chunk_mers = Vector{M}(undef, chunk_size)
    chunk_freqs = Vector{MerFreq{M}}()
    sizehint!(chunk_freqs, chunk_size)
    #sizehint!(chunk_mers, chunk_size)
    output = Vector{MerFreq{M}}()
    
    #@info "mers_per_read" 
    #@info "chunk_mers" chunk_mers
    
    read = first(range)
    lastread = last(range)
    read_sequence = LongDNASeq()
    
    mergen = each(M, load_sequence!(sbuf, read, read_sequence))
    mernext = iterate(mergen)
    chunkfill = 1
    
    @inbounds while read <= lastread
        while mernext !== nothing && chunkfill <= chunk_size
            chunk_mers[chunkfill] = canonical(mernext[1])
            chunkfill = chunkfill + 1
            mernext = iterate(mergen, mernext[2])
        end
        @info "finished inner while" chunkfill mernext
        if chunkfill > chunk_size
            #@info "Finished a chunk"
            collapse_into_freqs!(chunk_mers, chunk_freqs)
            merge_into_sorted!(output, chunk_freqs)
            chunkfill = 1
        else
            read = read + 1
            if read <= lastread
                mergen = each(M, load_sequence!(sbuf, read, read_sequence))
                mernext = iterate(mergen)
            end
        end
    end
    return output
end

function build_freq_list5(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}) where {M<:AbstractMer}
    chunk_mers = Vector{MerFreq{M}}(undef, length(range) * (300 - 31 + 1))
    wi = firstindex(chunk_mers)
    read_sequence = LongDNASeq()
    @inbounds for i in range
        for mer in each(M, load_sequence!(sbuf, i, read_sequence))
            chunk_mers[wi] = MerFreq{M}(canonical(mer), 0x01)
            wi = wi + 1
        end
    end
    resize!(chunk_mers, wi - 1)
    return collapse!(chunk_mers)
end
=#
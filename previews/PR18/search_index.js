var documenterSearchIndex = {"docs":
[{"location":"DeBruijnGraph/#de-Bruijn-Graph-type-1","page":"-","title":"de Bruijn Graph type","text":"","category":"section"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"A fundamental approach for de-novo gene assembly is to use make use of de Bruijn graphs. The graph is used to represent fragments of reads (mostly starting with kmers) as vertices and overlaps between these fragments as edges. DeBruijnGraph type is a special type of SequenceGraph. It is also made up of two fields:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"nodes\nlinks","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"struct DeBruijnGraph\n    nodes::Vector{SequenceGraphNode}\n    links::Vector{Vector{SequenceGraphLink}}\nend","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"We initialize a DeBruijnGraph using the deBruijn_constructor function. This is mainly due to the fact that arbitrary links between two vertices are not allowed in the de Bruijn graph formalism. The constructor receives as input a list of kmers and generates the deBruijn_Graph where each kmer is a unique vertex and each overlap  of length k-1 is represented with an edge.","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"kmer_vector = generate_random_kmers(DNA,4,10)\ndbg = deBruijn_constructor(kmer_vector)\n\nDeBruijnGraph(SequenceGraphNode[SequenceGraphNode{Kmer{DNA,4}}(CGCC, true), SequenceGraphNode{Kmer{DNA,4}}(TCTG, true), SequenceGraphNode{Kmer{DNA,4}}(TGTG, true), SequenceGraphNode{Kmer{DNA,4}}(GAAG, true), SequenceGraphNode{Kmer{DNA,4}}(GGCA, true), SequenceGraphNode{Kmer{DNA,4}}(ACGA, true), SequenceGraphNode{Kmer{DNA,4}}(CGCT, true), SequenceGraphNode{Kmer{DNA,4}}(TCTC, true), SequenceGraphNode{Kmer{DNA,4}}(TACG, true), SequenceGraphNode{Kmer{DNA,4}}(GCAT, true)], Array{SequenceGraphLink,1}[[], [], [], [], [SequenceGraphLink(-5, 10, 1)], [], [], [], [SequenceGraphLink(-9, 6, 1)], []])","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"We can use the fastq readers to work on real data. The example below generates the set of unique kmers from 5-long reads. The kmer size is set to 15.","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"r = FASTQ.Reader(open(\"URnano_ecoli.fastq\", \"r\"))\nEcoli_reads = Vector{BioSequence{DNAAlphabet{4}}}()\n\n## get first 5 reads\nfor i in 1:5\n    next_seq = iterate(r)\n    seq = sequence(next_seq[1])\n    next_seq = iterate(r,next_seq[2])\n    push!(Ecoli_reads,seq)\nend\nkmers = new_extract_canonical_kmers(Ecoli_reads,15)","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"The output is a set of kmers in their canonical form:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Set(Kmer{DNA,15}[AAAATATCTCGTTTT, TAAACCAGTCGCCGC, TTCGACATTACCCAG, CGCCCTGCCAGCAGT, TAATATTGTTCCATT, TGGTAATGGTCACAG, AAAAATTAAGCAGGA, ATATAAGTTATATCA, GCCCGATCTGTCTCC, GATTTCTCCGGGCCA  â€¦  TGAGCGATTGCCTGA, CGGAGCAGCAGTGTC, AAAATCGTACATACC, GTCGCCTGATGCCTG, GTCAGCGAACCTTCC, CGCCGCTCACCGCCG, TGGATGAACGTTCAT, AATATGTCACAATTT, ATGCGATAGCAGGGG, GTAGAAAGCTCGTGG, CGATTGGTTTAAGAC])","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Example data for checking node merging :","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"kmer_vector2 = Vector([DNAKmer{4}(\"ATTC\"),DNAKmer{4}(\"TTCG\"),DNAKmer{4}(\"TCGT\"),\n        DNAKmer{4}(\"AATC\"),DNAKmer{4}(\"AATG\"),DNAKmer{4}(\"CGTA\"),DNAKmer{4}(\"CGTC\")])","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"DeBruijnGraph for the above kmers:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"DeBruijnGraph(Dict{Int64,SequenceGraphNode}(7=>SequenceGraphNode{Kmer{DNA,4}}(ACGA, true),4=>SequenceGraphNode{Kmer{DNA,4}}(CGTC, true),2=>SequenceGraphNode{Kmer{DNA,4}}(AATG, true),3=>SequenceGraphNode{Kmer{DNA,4}}(ATTC, true),5=>SequenceGraphNode{Kmer{DNA,4}}(CGTA, true),6=>SequenceGraphNode{Kmer{DNA,4}}(CGAA, true),1=>SequenceGraphNode{Kmer{DNA,4}}(AATC, true)), Dict(7=>[SequenceGraphLink(-7, 6, -3)],4=>[SequenceGraphLink(4, 7, -3)],2=>[],3=>[SequenceGraphLink(3, 1, -3), SequenceGraphLink(3, 2, -3)],5=>[SequenceGraphLink(5, 7, -3)],6=>[SequenceGraphLink(-6, -3, -3)],1=>[]), 4)","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Then we apply node merging:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"DeBruijnGraph(Dict{Int64,SequenceGraphNode}(7=>SequenceGraphNode{BioSequence{DNAAlphabet{4}}}(ACGAAT, true),4=>SequenceGraphNode{Kmer{DNA,4}}(CGTC, true),2=>SequenceGraphNode{Kmer{DNA,4}}(AATG, true),5=>SequenceGraphNode{Kmer{DNA,4}}(CGTA, true),1=>SequenceGraphNode{Kmer{DNA,4}}(AATC, true)), Dict(7=>[SequenceGraphLink(-7, 6, -3), SequenceGraphLink(-7, 1, -3), SequenceGraphLink(-7, 2, -3)],4=>[SequenceGraphLink(4, 7, -3)],2=>[],5=>[SequenceGraphLink(5, 7, -3)],1=>[]), 4)","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"So the nodes with nodeID 6 and 3 are collapsed into node 7 and we can see that both outgoing edges of 3 are given to node 7.","category":"page"},{"location":"DeBruijnGraph/#Saving-to-gfa-1","page":"-","title":"Saving to gfa","text":"","category":"section"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Below is an example code for saving a SequenceDistanceGraph to GFA file. This allows us to load and visualize the graph using graph visualization tools.","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"# A helpful function to let me run Bandage to visualize graphs.\nconst BANDAGE_BIN = \"/Applications/Bandage.app/Contents/MacOS/Bandage\"\nfunction draw_graph(gr)\n    filename = tempname()\n    BioSequenceGraphs.dump_to_gfa1(gr, filename)\n    run(`$BANDAGE_BIN image $filename.gfa $filename.png --height 500`)\n    run(`open $filename.png`)\nend\nfunction show_graph(gr)\n    filename = tempname()\n    BioSequenceGraphs.dump_to_gfa1(gr, filename)\n    run(`$BANDAGE_BIN load $filename.gfa`)\nend","category":"page"},{"location":"man/guide/#Package-Guide-1","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/#Installation-1","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"GenomeGraphs is made available to install through BioJulia's package registry.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Julia by default only watches the \"General\" package registry, so before you start, you should add the BioJulia package registry.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Start a julia terminal, hit the ] key to enter pkg mode (you should see the prompt change from julia> to pkg>), then enter the following command:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"pkg> registry add https://github.com/BioJulia/BioJuliaRegistry.git","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"After you've added the registry, you can install GenomeGraphs from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"pkg> add GenomeGraphs","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"man/guide/#Creating-your-first-WorkSpace-1","page":"Guide","title":"Creating your first WorkSpace","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"You can create an empty genome graph workspace with the empty constructor:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"using GenomeGraphs\n\nws = WorkSpace()","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Obviously this workspace is quite useless on its own!","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"You need a genome graph and information to project onto it before you can do any exploration or analysis. There are a few ways to get your first graph:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Construct a de-Bruijn graph from raw sequencing reads.\nLoad a graph (such as produced from another assembler) from a GFAv1 file","category":"page"},{"location":"man/guide/#Constructing-your-first-de-Bruijn-graph-1","page":"Guide","title":"Constructing your first de-Bruijn graph","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Let's see how to do option number 1, and construct a de-Bruijn graph from raw sequencing reads. This can be achieved with a few simple steps:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Prepare the sequencing reads & build a datastore.\nAdd the read datastore to a WorkSpace.\nRun the dbg process.\nRun the tip removal process.","category":"page"},{"location":"man/guide/#Preparing-the-sequencing-reads-1","page":"Guide","title":"Preparing the sequencing reads","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Let's prepare the sequencing reads.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"WorkSpaces store sequencing reads in ReadDatastores, provided by the ReadDatastores.jl package.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"GenomeGraphs uses (and re-exports types and methods from) ReadDatastores. ReadDatastores is a standalone package in its own right (although it was built in the first place for GenomeGraphs).","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"If you want to use ReadDatastores as a standalone package in another Bio(Julia) based project (and we recommend you do - the data stores are more efficient than text files), you can find standalone docs for the package here. Some types and methods documented there, are repeated in the Library section of this manual here, for convenience.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Anyway, let's see how to build a paired end reads datastore!","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"using GenomeGraphs\n\nfwq = open(FASTQ.Reader, \"test/ecoli_pe_R1.fastq\")\nrvq = open(FASTQ.Reader, \"test/ecoli_pe_R2.fastq\")\n\nds = PairedReads(fwq, rvq, \"ecoli-test-paired\", \"my-ecoli\", 250, 300, 0, FwRv)","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Here \"ecoli-test-paired\" is provided as the base filename of the datastore, the datastore is given the name of \"my-ecoli\", this name will be used to identify it in the workspace later.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"The minimum length for the reads is set at 250 base pairs, and the maximum length is set to 300 base pairs. Reads that are too short will be discarded, reads that are too long are truncated.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"note: Note\nThe insert size of the paired reads to 0, since I'm not sure of it and right now the value is optional.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"I set the orientation of the paired reads to FwRv. This is the default, and means for every pair of reads, read 1 is oriented in the forward direction, and read 2 is oriented backwards (forwards on the opposite strand). This orientation distinguishes regular paired-end reads from other paired read types like Long Mate Pairs.","category":"page"},{"location":"man/guide/#Add-datastore-to-the-WorkSpace-1","page":"Guide","title":"Add datastore to the WorkSpace","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Now the datastore is created, it can be added to a workspace.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"ws = WorkSpace()\nadd_paired_reads!(ws, ds)","category":"page"},{"location":"man/guide/#Run-the-dbg-process-1","page":"Guide","title":"Run the dbg process","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"GenomeGraphs comes with some very high-level methods in it's API, that we like to call processes. They perform some critical and common task as part of a larger workflow. Examples include constructing a de-Bruijn graph from sequencing reads, mapping reads to a graph, kmer counting and so on.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Once a workspace has an attached read datastore, you can run the dbg process to produce a first de-Bruijn graph of the genome.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"dbg!(BigDNAMer{61}, 10, ws, \"my-ecoli\")","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"warning: Warning\nSome steps of this process, especially the Kmer counting steps, may take a long time for big inputs. No parallelism or batching to disk is used currently (although it is planned). This process should take just about a minute for E.coli paired end reads with a decent coverage. So, be warned, for big stuff, performance may suuuuuuucck in these early days!","category":"page"},{"location":"man/guide/#Run-the-remove_tips-process-1","page":"Guide","title":"Run the remove_tips process","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Now you have a raw compressed de-Bruijn assembly graph. You can start to use it for analyses, and also try to improve its structure and resolve parts of the graph that represent error, repetitive content, and so forth. Some of these structures can be identified and resolved using only the topology of the graph, some require additional information sources (linked reads / long reads / and so on), to be incorporated into the workspace first.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Here let's see how to resolve a common structure, using only the graph topology.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Let's fix the tips of the graph.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Tips looks like this:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"(Image: tips)","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"See how a piece of the assembly which should be one long stretch of sequence is broken into 3 pieces (red) because of the existence of two tips (blue). Such tips are defined topologically as very short segments which have one incoming neighbour, and no outgoing neighbour.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Tips are caused by sequencer errors that occur at the end of reads, because the sequencing by synthesis technique becomes more error prone over time; reagents are consumed and products generated as time progresses, making the base detection more difficult. Hence errors occur at the ends of reads, and erroneous kmers from the read ends are unlikely to have forward neighbours, and they end up forming tip nodes when they are incorporated into the de-Bruijn graph. ","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"you can remove these tips and improve the contiguity of the graph by using the remove_tips! process.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"remove_tips!(ws, 200)","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"The value of 200 provided is a size (in base pairs) threshold: Nodes are considered tips only if they have one ingoing neighbour, no outgoing neighbours, and are (in this case) smaller than 200 base pairs in length.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Once this process is finished you will have a collapsed de-Bruijn graph with the tips removed.","category":"page"},{"location":"man/guide/#Using-the-NodeView-interface-1","page":"Guide","title":"Using the NodeView interface","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Graphs can be complicated data structures. If you want an in depth explanation of the data-structure used to represent genome graphs, then head here.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"However, most people should not have to care about the internal structure of the graph.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"To make things as simple as possible, the NodeView type provides a single entry point for node-centric analyses. The NodeView wraps a point to a workspace's graph and contains a node id. A NodeView gives you acces to a node's underlying sequence, the nodes neighbouring nodes in the forward and backward directions, the reads mapped to a node, and kmer coverage over the node.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"To get a NodeView of a node, use the node method on a WorkSpace, providing a node id number. A positive ID denotes a view of the node traversing it in the forward (canonical) direction. A negative ID denotes a view of the node, traversing it in the reverse complement direction.   ","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"julia> n = node(ws, 3)\nA view of a graph node (node: 3, graph: sdg):\n  AAAAAACCTCCGCAACCCCATGTTTTCACATAACTGTTGâ€¦GCCATGACCGGCTGGCTGTCAGGCTGTCACTGATAATCA\n\n","category":"page"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"CurrentModule = GenomeGraphs.Graphs","category":"page"},{"location":"api/Graphs/#API:-The-Graphs-submodule-1","page":"Graphs submodule","title":"API: The Graphs submodule","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"The Graphs submodule contains the core graph data-structure used in GenomeGraphs.jl: The SequenceDistanceGraph.","category":"page"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"It also defines some of the common methods used in the rest of the higher-level parts GenomeGraphs.jl:","category":"page"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"To query nodes/sequences in the graph.\nTo find certain topological structures.\nTo edit graph structure.\nTo write/load SequenceDistanceGraph's to/from file.","category":"page"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"Some methods, particularly ones that access the sequences stored in the graph, and to edit topology, are marked as unsafe and are not exported deliberately.","category":"page"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"All types and methods defined in this module are documented here.","category":"page"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"note: Note\nThis is a reference of an internal sub-module's API for developers and experienced users. First ask yourself if what you need isn't covered by the higher-level WorkSpace API. ","category":"page"},{"location":"api/Graphs/#Types-1","page":"Graphs submodule","title":"Types","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"SequenceDistanceGraph\nSDG\nSDGNode\nSequenceDistanceGraphLink","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.SequenceDistanceGraph","page":"Graphs submodule","title":"GenomeGraphs.Graphs.SequenceDistanceGraph","text":"The SequenceDistanceGraph is a representation of a genome assembly.\n\nThe SequenceDistanceGraph stores sequences in a vector of SequenceDistanceGraphNodes (or SDGNode for short). \n\nA singe node represents a sequence and its reverse complement.\n\nEvery node also has an orientaton: Each node has a positive end (+), and a negative end (-). So when a node is accessed with (or traversed by entering) the positive end the node yields the stored sequence. Conversely, when a node is accessed with (or traversed by entering) the negative end the node yelds the reverse complement of the stored sequence. In this way the positive end can be thought of as the sequence start of the node's canonical sequence, and the negative end can be thought of as its end.\n\nThankfully, you don't need to think about \"positive node ends\" and \"negative  node ends\" most of the time you interact with a SequenceDistanceGraph: In a SequenceDistanceGraph, every has a correlative ID starting from 1. For every node stored in the graph with an ID X, the negative ID -X is mapped to the reverse complement of that node. This mapping is virtual: Only one node is stored in the graph. To see more about how these positive and negative node IDs work, refer to the docs for methods such as get_next_nodes and get_previous_nodes. These high level functions simplify coding graph traversal A LOT.\n\nThis SequenceDistanceGraph type is only intended to be interacted with directly by developers and users who know what they are doing. Most tasks an end user wants to do to manipulate or query a graph can be achieved through the  WorkSpace type and the NodeView interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Graphs/#GenomeGraphs.Graphs.SDG","page":"Graphs submodule","title":"GenomeGraphs.Graphs.SDG","text":"Shorthand for SequenceDistanceGraph\n\n\n\n\n\n","category":"type"},{"location":"api/Graphs/#GenomeGraphs.Graphs.SDGNode","page":"Graphs submodule","title":"GenomeGraphs.Graphs.SDGNode","text":"The SDGNode type represents a node in a SequenceDistanceGraph.\n\nAt present it contains only two fields, first it holds an instance of a BioSequences BioSequence type.\n\nSecondly, it tracks a flag which indicates if the node has been deleted or not.\n\nnote: Note\nThe deleted flag allows us to mark nodes in the graph as deleted, which can be of help in some algorithms where the graph structure is being edited (merging nodes for example).Actually deleting the node would shift node IDs and require redoing all links in the graph and so on.So just marking a node as deleted and not using it anymore is a lazy but sometimes helpful choice.\n\n\n\n\n\n","category":"type"},{"location":"api/Graphs/#GenomeGraphs.Graphs.SequenceDistanceGraphLink","page":"Graphs submodule","title":"GenomeGraphs.Graphs.SequenceDistanceGraphLink","text":"A SequenceDistanceGraphLink or SDGLink represents a single distance between two sequences in a SequenceDistanceGraph.\n\nEvery link describes a connection between two node ends and contains a distance (they take the form ([+, -]n1, [+, -]n2, [+, -]dist)).\n\nnote: Note\nA link connects two node ends, and so the order of the signed nodes in the links does not change the link.\n\nnote: Note\nIf the distance in a link is negative, this represents an overlap between two sequences. These overlaps must be perfect overlaps.\n\nnote: Note\nTwo links are considered equal (== will return true) if the source and the destination fields of the two links are the same, the distance or dist field is not considered!\n\n\n\n\n\n","category":"type"},{"location":"api/Graphs/#Public-/-Safe-methods-1","page":"Graphs submodule","title":"Public / Safe methods","text":"","category":"section"},{"location":"api/Graphs/#Graph-nodes-and-sequences-1","page":"Graphs submodule","title":"Graph nodes and sequences","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"name\nn_nodes\nsequence","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.name","page":"Graphs submodule","title":"GenomeGraphs.Graphs.name","text":"Get the name of the graph. Defaults to the symbol :sdg.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.n_nodes","page":"Graphs submodule","title":"GenomeGraphs.Graphs.n_nodes","text":"Get the number of nodes in the sequence distance graph sg.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.sequence","page":"Graphs submodule","title":"GenomeGraphs.Graphs.sequence","text":"sequence(sg::SequenceDistanceGraph, n::NodeID)\n\nGet the full sequence of a node in a sequence distance graph using its correlative node id n.\n\nnote: Note\nsequence accepts a NodeID that can be positive or negative. Nodes represent stretches of sequence in a canonical orientation, if you ask for for the sequence of say the third node, the positive node id 3 (which denotes traversing the third node in the forward direction), gives you the canonical sequence. If you use the negative ID -3 (which denotes traversing the third node in the reverse direction), you will get the reverse complement of the node's canonical (forward) sequence.\n\nnote: Note\nIt is safe to modify the returned sequence without screwing up your graph, yet thanks to BioSequences.jl's copy on write system for LongSequences, data copying will only occur if nessecery. You get the best of both worlds.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#Graph-Topology-1","page":"Graphs submodule","title":"Graph Topology","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"source\ndestination\ndistance\nis_forwards_from\nis_backwards_from\nfind_link\nforward_links\nbackward_links\nget_next_nodes\nget_previous_nodes\nfind_tip_nodes\nfind_tip_nodes!\nfind_all_unitigs\nfind_all_unitigs!","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.source","page":"Graphs submodule","title":"GenomeGraphs.Graphs.source","text":"Get the source node end of a link.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.destination","page":"Graphs submodule","title":"GenomeGraphs.Graphs.destination","text":"Get the destination node end of a link.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.distance","page":"Graphs submodule","title":"GenomeGraphs.Graphs.distance","text":"Get the distance between two node ends involved in a link.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.is_forwards_from","page":"Graphs submodule","title":"GenomeGraphs.Graphs.is_forwards_from","text":"Test if link l is a forward link leaving node n.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.is_backwards_from","page":"Graphs submodule","title":"GenomeGraphs.Graphs.is_backwards_from","text":"Test if link l is a forward link leaving node n.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.find_link","page":"Graphs submodule","title":"GenomeGraphs.Graphs.find_link","text":"find_link(sg::SequenceDistanceGraph, src::NodeID, dst::NodeID)\n\nFind and return the link that exists between a source node and a destination node, using their correlative node ids.\n\nIn this instance, the IDs also denote the \"ends\" of a node, a link connects.\n\nRecall that every node has an orientaton: Each node has a positive end (+), and a negative end (-). So when a node is accessed with (or traversed by entering) the positive end the node yields the stored sequence. Conversely, when a node is accessed with (or traversed by entering) the negative end the node yelds the reverse complement of the stored sequence.\n\nThus find_link(sg, -5, 1) means you want to find a link in the graph that allows you to exit the (-) end of node 5 (meaning you just traversed it in the  canonical + â€“> - orientation), and enter the (+) end of node 1 (meaning you will also traverse node one in the canonical + â€“> - orientation).\n\nBy contrast find_link(sg, -5, -1) means you want to find a link in the graph that allows you to exit the (-) end of node 5 - again having just traverse it in the + â€“> - orientation, but want to enter node 1 through it's (-) end - and thus traversing node 1 in the + <â€“ - orientation, yielding the reverse complement of the canonical sequence of node 1.\n\nIf a link connecting the two node ends is present, you get it. If not, you get nothing. So make sure to check the output.\n\nnote: Note\nThis method is safe and public, but not reeeeaaallly intended for the end user, as they have to worry about links between \"ends\" of a node. In contrast to the rest of this framework, which rather has the user thinking in node centric terms. e.g. \"I am at node 5 which means I have traversed it forwards or I am at node -5, which means I have traversed node 5 backwards. From here I can visit node 1, -3, and 2, so I may go through nodes 1 and 2 forwards, and through 3 backwards. The methods get_next_nodes and get_previous_nodes are more user-friendly and follow this more node-centric mindset.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.forward_links","page":"Graphs submodule","title":"GenomeGraphs.Graphs.forward_links","text":"forward_links(sg::SequenceDistanceGraph, n::NodeID)\n\nGet a vector of the links that are ahread of you, as you traverse node n, continuing forward in you present direction of travel (n can be a positive or negative node id).\n\nThe node id can be positive or negative. For example if you use a positive ID, such as 5, this means you are traversing node 5 in the canonical orientation, and so you will get the links that allow you to leave node 5 in the canonical direction. If you used a negative ID such as -5, that means you are traversing node 5 in the non-canonical orientation, and so you will get the links that allow you to leave node 5 in the non-canonical direction.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.backward_links","page":"Graphs submodule","title":"GenomeGraphs.Graphs.backward_links","text":"backward_links(sg::SequenceDistanceGraph, n::NodeID)\n\nGet a vector of the links that are behind of you, as you traverse node n, continuing forward in you present direction of travel (n can be a positive or negative node id).\n\nThe node id can be positive or negative. For example if you use a positive ID, such as 5, this means you are traversing node 5 in the canonical orientation, and so you will get the links that would allow you to enter node 5 in the canonical direction. If you used a negative ID such as -5, that means you are traversing node 5 in the non-canonical orientation, and so you will get the links that would allow you to enter node 5 in the non-canonical direction.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.get_next_nodes","page":"Graphs submodule","title":"GenomeGraphs.Graphs.get_next_nodes","text":"get_next_nodes(sg::SequenceDistanceGraph, n::NodeID)\n\nGet the nodes you may visit next as you exit node n, maintaining your current direction of travel (n can be a positive or negative node ID).\n\nnote: Note\nThe node id can be positive or negative. For example if you use a positive ID, such as 5, this means you are traversing node 5 in the canonical orientation, and so you will get the nodes you may visit as you leave node 5 in the canonical direction. If you use a negative ID, such as -5, this means you are traversing node 5 in the non-canonical orientation, and so you will get the nodes you may visit as you leave node 5 in the non-canonical direction.\n\nnote: Note\nThe list of nodes returned are also signed to denote direction: Say you got [1, -2, 3] as a result of get_next_nodes(sg, 5). That means as you leave node 5 after traversing it in the canonical direction, you may proceed to travel through nodes 1 and 3 in the canonical direction, and node 2 in the non-canonical direction.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.get_previous_nodes","page":"Graphs submodule","title":"GenomeGraphs.Graphs.get_previous_nodes","text":"get_previous_nodes(sg::SequenceDistanceGraph, n::NodeID)\n\nGet the nodes you may have previously been on before you enterd node n, maintaining your current direction of travel (n can be a positive or negative node ID).\n\nnote: Note\nThe node id can be positive or negative. For example if you use a positive ID, such as 5, this means you are traversing node 5 in the canonical orientation, and so you will get the nodes you may have visited prior to entering node 5 in the canonical direction. If you use a negative ID, such as -5, this means you are traversing node 5 in the non-canonical orientation, and so you will get the nodes you may have visited prior to entering node 5 in the non-canonical direction.\n\nnote: Note\nThe list of nodes returned are also signed to denote direction: Say you got [1, -2, 3] as a result of get_previous_nodes(sg, 5). That means prior to entering node 5 in the canonical direction, you may have traveled through nodes 1 and 3 in the canonical direction, and node 2 in the non-canonical direction.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.find_tip_nodes","page":"Graphs submodule","title":"GenomeGraphs.Graphs.find_tip_nodes","text":"find_tip_nodes(sg::SequenceDistanceGraph, min_size::Integer)\n\nGet a set of IDs of all the nodes in the graph sg that count as \"tips\".\n\nHere a tip node is defined as a node that only has a single neighbouring node at one of it's ends, and no neighbouring nodes out of one of its other end.\n\nThe node's sequence must also be larger than min_size base pairs in length.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.find_tip_nodes!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.find_tip_nodes!","text":"find_tip_nodes!(result::Set{NodeID}, sg::SequenceDistanceGraph, min_size::Integer)\n\nGet a set of IDs of all the nodes in the graph sg that count as \"tips\".\n\nHere a tip node is defined as a node that only has a single neighbouring node at one of it's ends, and no neighbouring nodes out of one of its other end.\n\nThe node's sequence must also be larger than min_size base pairs in length.\n\nnote: Note\nThis method modifys a result input. So if you want to find tips in a graph repeatedly, you can resuse a Set, saving you some allocation costs.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.find_all_unitigs","page":"Graphs submodule","title":"GenomeGraphs.Graphs.find_all_unitigs","text":"find_all_unitigs(sg::G, min_nodes::Integer) where {G<:SequenceDistanceGraph}\n\nFind and return a vector of paths through the graph that represent all the unitigs or transitive paths in the graphs. Such paths are defined as a chain of nodes with only one neighbour. Such simple regions of the graph can safely be collapsed into one larger node.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.find_all_unitigs!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.find_all_unitigs!","text":"find_all_unitigs!(unitigs::Vector{SequenceGraphPath{G}}, sg::G, min_nodes::Integer) where {G<:SequenceDistanceGraph}\n\nFind and return a vector of paths through the graph that represent all the unitigs or transitive paths in the graphs. Such paths are defined as a chain of nodes with only one neighbour. Such simple regions of the graph can safely be collapsed into one larger node.\n\nnote: Note\nThis vector modifies an input unitigs vector to contain the result. This is useful for situations where you want to repeatedly find unitigs in the graph to save on additional allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#Graph-IO-1","page":"Graphs submodule","title":"Graph IO","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"Graphs.write_to_gfa1\nGraphs.load_from_gfa1!","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.write_to_gfa1","page":"Graphs submodule","title":"GenomeGraphs.Graphs.write_to_gfa1","text":"write_to_gfa1(sg::SequenceDistanceGraph, filename::String)\n\nWrite a graph from a GFAv1 formatted file, and associated FASTA file of node sequences.\n\nnote: Note\nThe GFA format permits storing sequences of the graph nodes in a seperate fasta file, instead of in the GFA file. This is so as the sequences of the graph nodes can be easily fed into other tools that typically accept FASTA files as input. Many assemblers also output a GFA + FASTA combo.  Therefore, this method writes node sequences to a file called [filename].fasta, and the graph structure to a file called [filename].gfa.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.load_from_gfa1!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.load_from_gfa1!","text":"load_from_gfa1!(sg::SequenceDistanceGraph{S}, gfafile::AbstractString, fafile::AbstractString) where {S<:BioSequence}\n\nLoad a graph from a GFAv1 formatted file, and associated FASTA file of node sequences.\n\nnote: Note\nThe GFA format permits storing sequences of the graph nodes in a seperate fasta file, instead of in the GFA file. This is so as the sequences of the graph nodes can be easily fed into other tools that typically accept FASTA files as input. Many assemblers also output a GFA + FASTA combo.  Therefore, this method asks for the filepath of a GFAv1 file, as well as a filepath to a FASTA formatted file. This method reads the node sequences from the FASTA file, before getting the links between nodes from the GFAv1 file.   \n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#Internal-/-Unsafe-methods-1","page":"Graphs submodule","title":"Internal / Unsafe methods","text":"","category":"section"},{"location":"api/Graphs/#Graph-nodes-and-sequences-2","page":"Graphs submodule","title":"Graph nodes and sequences","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"Graphs.empty_seq\nGraphs.is_deleted\nGraphs.unsafe_sequence\nGraphs.check_node_id\nGraphs.nodes\nGraphs.node_unsafe\nGraphs.node","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.empty_seq","page":"Graphs submodule","title":"GenomeGraphs.Graphs.empty_seq","text":"empty_seq(::Type{LongSequence{DNAAlphabet{2}}})\n\nGet a reference to an empty 2-bit long dna sequence.\n\nIn this module, a single empty sequence is allocated, and every call to empty_seq returns a reference to that same allocated sequence.\n\nThis saves on allocations if you are deleting many nodes in a SequenceDistanceGraph.\n\n\n\n\n\nempty_seq(::Type{LongSequence{DNAAlphabet{4}}})\n\nGet a reference to an empty 4-bit long dna sequence.\n\nIn this module, a single empty sequence is allocated, and every call to empty_seq returns a reference to that same allocated sequence.\n\nThis saves on allocations if you are deleting many nodes in a SequenceDistanceGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.is_deleted","page":"Graphs submodule","title":"GenomeGraphs.Graphs.is_deleted","text":"Check if a SDGNode is a deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.unsafe_sequence","page":"Graphs submodule","title":"GenomeGraphs.Graphs.unsafe_sequence","text":"unsafe_sequence(n::SDGNode{S}) where {S<:BioSequence}\n\nGet the reference to a node's underlying sequence object.\n\nwarning: Warning\nYou get a reference to the node's sequence object - not a copy. So doing transformation operations (reverse_complement, setindex, etc.) to it will probably screw up the graph!\n\n\n\n\n\nunsafe_sequence(sg::SequenceDistanceGraph, n::NodeID)\n\nGet the reference to a node's underlying sequence object.\n\nwarning: Warning\nThis method is unsafe, no checking of node id's occurs and you get a reference to the node's sequence object - not a copy, so doing transformation operations (reverse_complement, setindex, etc.) to it will probably screw up the graph!\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.check_node_id","page":"Graphs submodule","title":"GenomeGraphs.Graphs.check_node_id","text":"check_node_id(sg::SequenceDistanceGraph, i::NodeID)\n\nThe method responsible for checking that a node id used as input to a method that queries or edits a SequenceDistanceGraph is a sensible value.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.nodes","page":"Graphs submodule","title":"GenomeGraphs.Graphs.nodes","text":"Get a reference to the vector of nodes in a graph sg.\n\nwarning: Warning\nIt is a bad idea to edit this vector yourself unless you know what you are doing.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.node_unsafe","page":"Graphs submodule","title":"GenomeGraphs.Graphs.node_unsafe","text":"node_unsafe(sg::SequenceDistanceGraph, n::NodeID)\n\nGet a reference specific node from a sequence distance graph sg using its correlative node id n.\n\nnote: Note\nnode_unsafe accepts a NodeID that can be positive or negative. E.g. providing either 5 or -5 both mean node 5 in a graph, and so you will get the node for node 5.\n\nwarning: Warning\nThis method returns a reference to a graph's underlying SDGNode. NOT a copy! Messing with this will screw up your graph. So this method is not recommended or exported - unless you really know what you're doing.\n\nwarning: Warning\nThis method is explicitly marked unsafe for a reason. It does zero checking of the value it is passed as the node id. It also makes use of the @inbounds macro. This makes it faster, but you need to be 100% sure that your code won't try to call this with a bad id. So it is not exported or recommendedunless you really know what you're doing.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.node","page":"Graphs submodule","title":"GenomeGraphs.Graphs.node","text":"node(sg::SequenceDistanceGraph, n::NodeID)\n\nGet a reference to a specific node from a sequence distance graph sg using its correlative node id n.\n\nnote: Note\nnode accepts a NodeID that can be positive or negative. E.g. providing either 5 or -5 both mean node 5 in a graph, and so you will get the links for node 5.\n\nwarning: Warning\nThis method returns a reference to a graph's underlying SDGNode. NOT a copy! Messing with this will screw up your graph. So this method is not recommended or exported - unless you really know what you're doing.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#Graph-topology-1","page":"Graphs submodule","title":"Graph topology","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"Graphs.links\nGraphs.linksof_unsafe","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.links","page":"Graphs submodule","title":"GenomeGraphs.Graphs.links","text":"Get a reference to the vector of vectors of links in a graph sg.\n\nwarning: Warning\nIt is a bad idea to edit this vector yourself unless you know what you are doing.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.linksof_unsafe","page":"Graphs submodule","title":"GenomeGraphs.Graphs.linksof_unsafe","text":"linksof_unsafe(sg::SequenceDistanceGraph, n::NodeID)\n\nGet a reference to a vector storing all the links of a node in a SequenceDistanceGraph, the node is specified using its correlative node id n.\n\nnote: Note\nlinks_unsafe accepts a NodeID that can be positive or negative. E.g. providing either 5 or -5 both mean node 5 in a graph, and so you will get the links for node 5.\n\nwarning: Warning\nThis method returns a reference to an underlying links vector that the SequenceDistanceGraph owns - NOT a copy! Messing with this will screw up your graph. So this method is not recommended or exported - unless you really know what you're doing.\n\nwarning: Warning\nThis method is explicitly marked unsafe for a reason. It does zero checking of the value it is passed as the node id. It also makes use of the @inbounds macro. This makes it faster, but you need to be 100% sure that your code won't try to call this with a bad id. So it is not exported or recommendedunless you really know what you're doing.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#Graph-editing-and-manipulation-1","page":"Graphs submodule","title":"Graph editing and manipulation","text":"","category":"section"},{"location":"api/Graphs/#","page":"Graphs submodule","title":"Graphs submodule","text":"Graphs.add_node!\nGraphs.remove_node!\nGraphs.add_link!\nGraphs.remove_link!\nGraphs.disconnect_node!\nGraphs.collapse_all_unitigs!","category":"page"},{"location":"api/Graphs/#GenomeGraphs.Graphs.add_node!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.add_node!","text":"add_node!(sg::SequenceDistanceGraph{S}, n::SDGNode{S}) where {S<:BioSequence}\n\nAdd a node n to a graph sg.\n\nReturns the node ID used to access the new node added in the graph.\n\nwarning: Warning\nWe don't enforce the sequence in the node is canonical here. We just trust that it is canonical.\n\nwarning: Warning\nAdding a node to the graph does just that. After adding the node it still will not be linked to any other nodes.\n\n\n\n\n\nadd_node!(sg::SequenceDistanceGraph{S}, seq::BioSequence) where {S<:BioSequence}\n\nAdd a sequence to a sequence distance graph as a node.\n\nReturns the node ID used to access the new node added in the graph.\n\nCan accept any sequence type and will attempt to coerce the input sequence to the type required by the graph.\n\nwarning: Warning\nWe don't enforce the sequence in the node is canonical here. We just trust that it is canonical.\n\nwarning: Warning\nAdding a node to the graph does just that. After adding the node it still will not be linked to any other nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.remove_node!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.remove_node!","text":"remove_node!(sg::SequenceDistanceGraph{S}, n::NodeID) where {S<:BioSequence}\n\nRemove a node from a sequence distance graph.\n\nnote: Note\nThis method can accepts a NodeID that can be positive or negative. E.g. providing either 5 or -5 both mean node 5 in a graph, and so you will end up deleting node 5.\n\nnote: Note\nLinks involving this node will also be removed from the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.add_link!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.add_link!","text":"add_link!(sg::SequenceDistanceGraph, source::NodeID, dest::NodeID, dist::Int)\n\nConstruct a link between two node ends in a sequence Graph.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.remove_link!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.remove_link!","text":"remove_link!(sg::SequenceDistanceGraph, src::NodeID, dst::NodeID)\n\nRemove a link between two nodes in a SequenceDistanceGraph. Returns a boolean indicating whether the removal was successful. Reasons this function would not return true include that the link didn't exist in the graph, and so could not be removed.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.disconnect_node!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.disconnect_node!","text":"Removes all the links in the collection from and to a given nodeID.\n\n\n\n\n\n","category":"function"},{"location":"api/Graphs/#GenomeGraphs.Graphs.collapse_all_unitigs!","page":"Graphs submodule","title":"GenomeGraphs.Graphs.collapse_all_unitigs!","text":"collapse_all_unitigs!(sg::SequenceDistanceGraph, min_nodes::Integer, consume::Bool)\n\nDetects all of the trivial paths through the graph that define unitigs. Such paths are defined as a chain of nodes with only one neighbour. Each such simple paths through the graph can safely be collapsed into one larger node, which is what this function does.\n\nnote: Note\nThis method will edit unitigs so as after this method returns it contains All the paths that were detected as unitigs in the graph. This method also edits the newnodes vector, so as after this method returns it contains the IDs of all new nodes that were created as a result of collapsing the paths in unitigs.\n\nnote: Note\nModifies the SequenceDistanceGraph sg.\n\n\n\n\n\ncollapse_all_unitigs!(sg::SequenceDistanceGraph, min_nodes::Integer, consume::Bool)\n\nDetects all of the trivial paths through the graph that define unitigs. Such paths are defined as a chain of nodes with only one neighbour. Each such simple paths through the graph can safely be collapsed into one larger node, which is what this function does.\n\nnote: Note\nModifies the SequenceDistanceGraph sg.\n\n\n\n\n\n","category":"function"},{"location":"#GenomeGraphs-1","page":"Home","title":"GenomeGraphs","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A graph based genomics framework for the julia/BioJulia ecosystem.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Latest release) (Image: MIT license)  (Image: Stable documentation) (Image: Pkg Status) (Image: Chat)","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"GenomeGraphs is designed to do one thing - provide a framework that makes it simple for a human to work with genome graphs from scripts or interactively.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Graphs are the core representation used by genome assemblers to represent genome sequence models constructed from reads. At the time of writing it is fair to say that until recently, their use has been limited to the internals of genome assemblers, which are often treated as black boxes that output a series of flattened sequences in FASTA format.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The use of graphs has increased in recent years thanks to the GFA file format and developments in genome variation graphs and sequence to graph mappers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, a lack of inter operation between graph-based tools, and limited tools for downstream graph-based analysis, contribute to a perceived complexity which maintains linear sequences and FASTA files as the typical unit of genomic sequence exchange.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Such flattening of graph representations within pipelines with multiple steps, that use different types of sequencing in an iterative fashion, produces ever-longer linear genome sequences through an information loss process.  As a result, genome assembly projects are prone to error propagation and difficult to reproduce and control.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To address these problems for the BioJulia ecosystem, GenomeGraphs provides a flexible framework for building and integrating information over genome graphs.","category":"page"},{"location":"#Framework-overview-1","page":"Home","title":"Framework overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package implements a SequenceDistanceGraph type that represents sequences as nodes and the adjacency between sequences in links/edges. Rather than work directly with this graph data structure, you interact with a WorkSpace. A WorkSpace associates a SequenceDistanceGraph with raw sequencing reads,  sequence to graph mappings, and k-mer counts. The WorkSpace and the API  provides a working environment that enables you to project different kinds of  information over a graph, and navigate and analyse each node of a sequence graph.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Within the WorkSpace, you will find DataStore types permit random access to short, linked, and long read sequences stored on disk in BioSequences.jl's native bit encoding. Each datastore has an associated Mapper in the workspace that contains the output from mapping said reads onto the graph. KmerCounts allow you to compute k-mer coverage over the graph from sequencing data, enabling coverage analysis. Additional DistanceGraphs define alternative topologies over SequenceDistanceGraph nodes. They are typically used to represent longer range linkage information from various sequencing technologies.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, a NodeView abstraction provides a proxy to a node, with methods to navigate a graph and access mapped data.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This framework is intended to allow the user to expore genome graphs interactively and to create processing methods for assembly or downstream analyses.","category":"page"},{"location":"#TLDR;-Package-features-1","page":"Home","title":"TLDR; Package features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient on-disk (buffered) data stores for sequencing reads.\nA simple graph data-structure for representing assembled genomes.\nTODO: Transparent mapping of sequencing reads onto graphs.\nTODO: Kmer counts and coverage projection over genome graph nodes.\nWorkspaces binding a genome graph, mapped sequences, kmer counts, and annotation.\nDe-novo genome assembly utilities:\nde-Bruijn graph construction, with tip-clipping & bubble-popping.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Guide section of the manual for a tutorial explaining how to get started using GenomeGraphs.","category":"page"},{"location":"api/MerTools/#","page":"API: The MerTools submodule","title":"API: The MerTools submodule","text":"CurrentModule = GenomeGraphs.MerTools","category":"page"},{"location":"api/MerTools/#API:-The-MerTools-submodule-1","page":"API: The MerTools submodule","title":"API: The MerTools submodule","text":"","category":"section"},{"location":"api/MerTools/#","page":"API: The MerTools submodule","title":"API: The MerTools submodule","text":"note: Note\nThis is a reference of an internal sub-module's API for developers and experienced users. First ask yourself if what you need isn't covered by the higher-level WorkSpace API. ","category":"page"},{"location":"api/MerTools/#Types-1","page":"API: The MerTools submodule","title":"Types","text":"","category":"section"},{"location":"api/MerTools/#","page":"API: The MerTools submodule","title":"API: The MerTools submodule","text":"MerCount\nMerCountHist\nDNAMerCount\nRNAMerCount","category":"page"},{"location":"api/MerTools/#GenomeGraphs.MerTools.MerCount","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.MerCount","text":"A simple mer count struct.\n\nMerCount is a simple struct that binds a mer value to a count of the number of times it has been observed. This type, (sorted) vectors of them, and some additional utility methods, form the basic building blocks of the higher-level mer counting functionality of the MerTools sub-module. \n\nnote: Note\nThe count is stored as an UInt8 because often once the count is more than 255 we hardly care anymore.\n\n\n\n\n\n","category":"type"},{"location":"api/MerTools/#GenomeGraphs.MerTools.DNAMerCount","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.DNAMerCount","text":"Shorthand for MerCount{DNAMer{K}}\n\n\n\n\n\n","category":"type"},{"location":"api/MerTools/#GenomeGraphs.MerTools.RNAMerCount","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.RNAMerCount","text":"Shorthand for MerCount{RNAMer{K}}\n\n\n\n\n\n","category":"type"},{"location":"api/MerTools/#Public-/-Safe-methods-1","page":"API: The MerTools submodule","title":"Public / Safe methods","text":"","category":"section"},{"location":"api/MerTools/#","page":"API: The MerTools submodule","title":"API: The MerTools submodule","text":"mer\nfreq\ncollapse_into_counts\ncollapse_into_counts!\nmerge_into!","category":"page"},{"location":"api/MerTools/#GenomeGraphs.MerTools.mer","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.mer","text":"Get the mer from a MerCount.\n\n\n\n\n\n","category":"function"},{"location":"api/MerTools/#GenomeGraphs.MerTools.freq","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.freq","text":"Get the count from a MerCount.\n\n\n\n\n\nGet the count from a MerCount, and convert it to type R.\n\n\n\n\n\n","category":"function"},{"location":"api/MerTools/#GenomeGraphs.MerTools.collapse_into_counts","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.collapse_into_counts","text":"collapse_into_counts(mers::Vector{M}) where {M<:AbstractMer}\n\nBuild a vector of sorted MerCounts from a Vector of a mer type.\n\nThis is a basic kernel function used for any higher level and more complex kmer counting procedures.\n\n\n\n\n\n","category":"function"},{"location":"api/MerTools/#GenomeGraphs.MerTools.collapse_into_counts!","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.collapse_into_counts!","text":"collapse_into_counts!(result::Vector{MerCount{M}}, mers::Vector{M}) where {M<:AbstractMer}\n\nBuild a vector of sorted MerCounts from a Vector of a mer type.\n\nThis is a basic kernel function used for any higher level and more complex kmer counting procedures.\n\nThis is like collapse_into_counts, except it's first argument is a result vector that is cleared and filled with the result.\n\nnote: Note\nThe input vector mers will be sorted by this method.\n\n\n\n\n\n","category":"function"},{"location":"api/MerTools/#GenomeGraphs.MerTools.merge_into!","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.merge_into!","text":"merge_into!(a::Vector{MerCount{M}}, b::Vector{MerCount{M}}) where {M<:AbstractMer}\n\nMerge the MerCounts from vector b into the vector a.\n\nnote: Note\nThis will sort the input vectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"api/MerTools/#Internal-/-Unsafe-methods-1","page":"API: The MerTools submodule","title":"Internal / Unsafe methods","text":"","category":"section"},{"location":"api/MerTools/#","page":"API: The MerTools submodule","title":"API: The MerTools submodule","text":"unsafe_collapse_into_counts!\nunsafe_merge_into!","category":"page"},{"location":"api/MerTools/#GenomeGraphs.MerTools.unsafe_collapse_into_counts!","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.unsafe_collapse_into_counts!","text":"unsafe_collapse_into_counts!(result::Vector{MerCount{M}}, mers::Vector{M}) where {M<:AbstractMer}\n\nwarning: Warning\nThis method is marked as unsafe because it assumes that the mers input vector is already sorted.\n\n\n\n\n\n","category":"function"},{"location":"api/MerTools/#GenomeGraphs.MerTools.unsafe_merge_into!","page":"API: The MerTools submodule","title":"GenomeGraphs.MerTools.unsafe_merge_into!","text":"unsafe_merge_into!(a::Vector{MerCount{M}}, b::Vector{MerCount{M}}) where {M<:AbstractMer}\n\nMerge the MerCounts from vector b into the vector a.\n\nwarning: Warning\nThis method is marked as unsafe as it assumes both of the input vectors a and b are already sorted.\n\n\n\n\n\n","category":"function"}]
}

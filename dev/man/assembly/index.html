<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Genome Assembly · GenomeGraphs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="GenomeGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">GenomeGraphs.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>Genome Assembly</a><ul class="internal"><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Constructing-your-first-de-Bruijn-graph-1"><span>Constructing your first de Bruijn graph</span></a></li><li><a class="tocitem" href="#Using-the-NodeView-interface-1"><span>Using the NodeView interface</span></a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/Graphs/">Graphs submodule</a></li><li><a class="tocitem" href="../../api/GraphIndexes/">GraphIndexes submodule</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Genome Assembly</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Genome Assembly</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BioJulia/GenomeGraphs.jl/blob/master/docs/src/man/assembly.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Genome-Assembly-with-GenomeGraphs.jl-1"><a class="docs-heading-anchor" href="#Genome-Assembly-with-GenomeGraphs.jl-1">Genome Assembly with GenomeGraphs.jl</a><a class="docs-heading-anchor-permalink" href="#Genome-Assembly-with-GenomeGraphs.jl-1" title="Permalink"></a></h1><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>The genome assembly problem is one of taking raw sequence read data from one or multiple sequencing experiments, and constructing an accurate genome sequence (or sequences).</p><p>The hallmarks of an accurate genome assembly is one that:</p><ol><li>Contains the correct motifs...</li><li>the correct number of times...</li><li>and in the correct order.</li></ol><p>Read those three again.</p><p>... and again.</p><p>... ok. As an aside - you may have noticed that metrics commonly reported in genome assembly papers, such as N50 or N95, don&#39;t actually tell you much - if anything - about how well your assembly satisfies those three hallmarks.</p><p>Ideally at the end of the process the genome assembly would have a single complete sequence for every unique haplotype in the genome. This does not happen for most genome assemblies, but fear not, genome assemblies are perfectly useful for most applications even if they are not 100% resolved.</p><p>This guide will take you from raw data to a genome assembly using the GenomeGraphs framework.</p><p>One common approach to the problem is to decompose the sequencing data into kmers,  So-called &quot;tip&quot; nodes, commonly caused by certain sequencing technologies may also be trimmed from the graph.</p><h2 id="Constructing-your-first-de-Bruijn-graph-1"><a class="docs-heading-anchor" href="#Constructing-your-first-de-Bruijn-graph-1">Constructing your first de Bruijn graph</a><a class="docs-heading-anchor-permalink" href="#Constructing-your-first-de-Bruijn-graph-1" title="Permalink"></a></h2><p>A common way to start to produce a genome assembly is to first construct a compressed de Bruijn graph from some raw sequencing data.</p><p>This results in a so-called unitig-graph which represents a partially complete solution to your genome assembly problem.</p><p>Such a unitig-graph will have placed many motifs into some kind of order. Specifically, all the kmers of a single unitig node&#39;s sequence have been placed into an order relative to each other.</p><p>However, as per the definition of a de Bruijn graph, many motifs are not present the correct number of times. Motifs that appear more than once in the genome either because of homozygosity or because the motif is common or repetitive are collapsed into single nodes, and so exist in the graph once. Such motifs occur in graph nodes situated in regions of the graph with more complex topology, and genome assembler programs use various heuristics to make decisions to correct the graph&#39;s structure in those regions. Successfully resolving such regions results in a simpler graph topology placing more motifs the correct number of times, in the correct right order. The graph topology for a completely resolved genome would look like a set of very long disconnected nodes; one node for each haplotype in the genome.</p><p>Let&#39;s not worry about regions of complex graph topology and heuristics that solve them just yet. Let&#39;s just worry about getting your first compressed de Bruijn graph from raw sequencing data.</p><p>This can be achieved with a few simple steps:</p><ol><li>Prepare some sequencing reads.</li><li>Decompose the sequencing reads into kmers.</li><li>Check and filter the kmers.</li><li>Use the <code>dbg</code> function on the kmers.</li></ol><p>Let&#39;s walk through this process with some <em>E. coli</em> paired end read data.</p><h3 id="Preparing-the-sequencing-reads-1"><a class="docs-heading-anchor" href="#Preparing-the-sequencing-reads-1">Preparing the sequencing reads</a><a class="docs-heading-anchor-permalink" href="#Preparing-the-sequencing-reads-1" title="Permalink"></a></h3><p>The first thing we are going to do is prepare a datastore for some paired-end Illumina sequencing reads.</p><p>Anyway, let&#39;s see how to build a paired end reads datastore!</p><pre><code class="language-julia">using GenomeGraphs

ds = read_datastore(&quot;test/ecoli_pe_R1.fastq&quot;, &quot;test/ecoli_pe_R2.fastq&quot;, &quot;ecoli-pe&quot;, 250, 301, 0, FwRv)</code></pre><p>Here &quot;ecoli-pe&quot; is provided as the base filename of the datastore file that will be created in the current working directory.</p><p>The minimum length for the reads is set at 250 base pairs, and the maximum length  is set to 301 base pairs. Read pairs with a read that is too short will be discarded. Reads that are too long are truncated to the maximum size.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The insert size of the paired reads is set to 0, since I&#39;m not sure of it and right now the value is optional and irrelevant for what we are about to do.</p></div></div><p>I set the orientation of the paired reads to <code>FwRv</code>. This is the default, and means for every pair of reads, read 1 is oriented in the forward direction, and read 2 is oriented backwards (forwards on the opposite strand). This orientation distinguishes regular paired-end reads from other paired read types like Long Mate Pairs.</p><h3 id="Decompose-the-sequencing-reads-into-kmers-1"><a class="docs-heading-anchor" href="#Decompose-the-sequencing-reads-into-kmers-1">Decompose the sequencing reads into kmers</a><a class="docs-heading-anchor-permalink" href="#Decompose-the-sequencing-reads-into-kmers-1" title="Permalink"></a></h3><p>Ok now we have our reads sorted into a read datastore we must decompose the reads into kmers that can be used to build the de Bruijn graph. This is one of the more computationally heavy steps of the process: Counting kmers is simple conceptually, but people are always trying to come up with ways of doing it faster, and on bigger datasets.</p><p>Several Kmer counting functions are available for this task, which use different parallelism and memory management strategies. Some store all data in RAM, some use multithreaded or multi-process parallelism, some use disk-backed and indexed datastores.</p><p>This is so as the user can pick the strategy according to need. For example, a user lacking the luxury of a large memory machine and with a large dataset, might use a strategy that uses disk batches. Such a strategy would sacrifice some speed as disk accession is costly, but they gain the ability to compute datasets otherwise too big to be workable.</p><p>This example is only E.coli though, so a laptop like a MacBook Pro model with 16GB  can handle this example just fine. Therefore I&#39;ll just use the &quot;serial_mem&quot; kmer counter. This counter uses no parallelism, and keeps all kmers generated in RAM. It takes ~30 seconds for my MacBook pro to run this example.</p><pre><code class="language-julia"># Create a serial_mem counter.
sm = serial_mem(DNAMer{31}, CANONICAL)
# Use counter to count kmers in the paired read datastore.
read_kcounts = sm(ds)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is very important to set the mode to <code>CANONICAL</code>!</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The serial_mem counter stores an internal buffer of counts and so if you are not going to run the counter again (which would edit that buffer), there&#39;s a performance optimisation you can do here to avoid making a copy of the buffer. But you need to <code>import KmerAnalysis</code>, which is one of the packages GenomeGraphs depends on.</p><pre><code class="language-julia">import KmerAnalysis
# Create the counter.
sm = serial_mem(DNAMer{31}, CANONICAL)
read_kcounts = KmerAnalysis.count!(sm, ds)</code></pre></div></div><p>Ok now we have a variable called <code>kmers</code> that stores the kmer counts from the read dataset. For every unique canonical kmer in the dataset, there is an entry listing that kmer and its count in the full read dataset.</p><h3 id="Check-the-Kmer-Frequency-Spectra-1"><a class="docs-heading-anchor" href="#Check-the-Kmer-Frequency-Spectra-1">Check the Kmer Frequency Spectra</a><a class="docs-heading-anchor-permalink" href="#Check-the-Kmer-Frequency-Spectra-1" title="Permalink"></a></h3><p>Now we have counted the canonical kmers in the read dataset we need to have a look at the kmer frequency spectra and check that we have a decent separation of the distributions corresponding to actual genome content, and the distribution that corresponds to sequencing error.</p><pre><code class="language-julia">speccy = spectra(kmers)</code></pre><p>Graphics and visualisation are currently not built into GenomeGraphs, because julia has a few different plotting frameworks and we don&#39;t want to force a user into using one vs the other, and they are also very heavy dependencies.</p><p>However, some Makie.jl based visualisation of kmer frequency spectra is provided by KmerAnalysisMakie.jl, which is a Makie companion to the KmerAnalysis.jl package.</p><pre><code class="language-julia">using Makie, KmerAnalysisMakie

plot(speccy)

limits = FRect(0, 0, 100, 500_000)
plot(speccy, limits = limits)</code></pre><p>Ok we can clearly see a nice separation between two distributions. The distribution that shoots off the plot where y = 1, represents all the many kmers in the read dataset that appear only once in the dataset. These kmers are likely the result of sequencing error - assuming the errors the sequencer makes are sufficiently random, and infrequent (which for Illumina Pair End sequencing, is the case).</p><p>The second distribution, centred around <code>40 &lt; x &lt; 50</code> is the main sampling distribution of the genuine motifs that exist in genome. It is centred on an x axis value approximate to the sequencing depth chosen for the sequencing experiment. This central value makes sense. Say, you chose to conduct a sequence experiment such that the genome should have been covered by the sequencer 50 times, you&#39;d expect genuine kmers that exist in the genome to have been observed ~50 times. Some kmers will be covered more times, perhaps because they are parts of motifs that are common or repeat across the genome. Some motifs don&#39;t appear as frequently because of sources of error during DNA sample prep, or are parts of the genome a sequencer finds hard to cover, because of the specifics of how the machines and or their chemistry work. Hence, we get a distribution around a central value close to the expected genome coverage.</p><p>We want don&#39;t want to include kmers that constitute the error distribution, in  our genome assembly, so we will filter to get rid of them. From the plot you can see any x value cutoff of 10 would be fine. </p><pre><code class="language-julia">filt_kmers = [mer(x) for x in read_kcounts if freq(x) ≥ 10]</code></pre><h3 id="Use-the-dbg-function-on-the-kmers-1"><a class="docs-heading-anchor" href="#Use-the-dbg-function-on-the-kmers-1">Use the <code>dbg</code> function on the kmers</a><a class="docs-heading-anchor-permalink" href="#Use-the-dbg-function-on-the-kmers-1" title="Permalink"></a></h3><p>The <code>dbg</code> function is GenomeGraphs&#39; compressed de Bruijn graph builder utility.</p><p>It is a fairly simple algorithm to read and comprehend, and runs in a series of &quot;stages&quot; - internal methods that can be easily overloaded for custom types, with sensible fallback defaults that hopefully don&#39;t destroy performance. </p><pre><code class="language-julia">graph = empty_graph(LongSequence{DNAAlphabet{4}})
dbg!(graph, filt_kmers, 10)</code></pre><p>Ok, this is one of the more meatier steps of the process.</p><h3 id="Check-the-Kmer-Frequency-Spectra-again-1"><a class="docs-heading-anchor" href="#Check-the-Kmer-Frequency-Spectra-again-1">Check the Kmer Frequency Spectra again</a><a class="docs-heading-anchor-permalink" href="#Check-the-Kmer-Frequency-Spectra-again-1" title="Permalink"></a></h3><pre><code class="language-julia">graph_kcount = sm([x.seq for x in graph.nodes])
sect = spectra(reads_kcount, graph_kcount)

spectracn(sect)</code></pre><h3 id="Run-the-remove_tips-process-1"><a class="docs-heading-anchor" href="#Run-the-remove_tips-process-1">Run the <code>remove_tips</code> process</a><a class="docs-heading-anchor-permalink" href="#Run-the-remove_tips-process-1" title="Permalink"></a></h3><p>Now you have a raw compressed de-Bruijn assembly graph. You can start to use it for analyses, and also try to improve its structure and resolve parts of the graph that represent error, repetitive content, and so forth. Some of these structures can be identified and resolved using only the topology of the graph, some require additional information sources (linked reads / long reads / and so on), to be incorporated into the workspace first.</p><p>Here let&#39;s see how to resolve a common structure, using only the graph topology.</p><p>Let&#39;s fix the tips of the graph.</p><p>Tips looks like this:</p><p><img src="../tips.jpeg" alt="tips"/></p><p>See how a piece of the assembly which should be one long stretch of sequence is broken into 3 pieces (red) because of the existence of two tips (blue). Such tips are defined topologically as very short segments which have one incoming neighbour, and no outgoing neighbour.</p><p>Tips are caused by sequencer errors that occur at the end of reads, because the sequencing by synthesis technique becomes more error prone over time; reagents are consumed and products generated as time progresses, making the base detection more difficult. Hence errors occur at the ends of reads, and erroneous kmers from the read ends are unlikely to have forward neighbours, and they end up forming tip nodes when they are incorporated into the de-Bruijn graph. </p><p>you can remove these tips and improve the contiguity of the graph by using the <code>remove_tips!</code> process.</p><pre><code class="language-julia">remove_tips!(ws, 200)</code></pre><p>The value of 200 provided is a size (in base pairs) threshold: Nodes are considered tips only if they have one ingoing neighbour, no outgoing neighbours, and are (in this case) smaller than 200 base pairs in length.</p><p>Once this process is finished you will have a collapsed de-Bruijn graph with the tips removed.</p><h2 id="Using-the-NodeView-interface-1"><a class="docs-heading-anchor" href="#Using-the-NodeView-interface-1">Using the NodeView interface</a><a class="docs-heading-anchor-permalink" href="#Using-the-NodeView-interface-1" title="Permalink"></a></h2><p>Graphs can be complicated data structures. If you want an in depth explanation of the data-structure used to represent genome graphs, then head <a href="man/notyet">here</a>.</p><p>However, most people should not have to care about the internal structure of the graph.</p><p>To make things as simple as possible, the <code>NodeView</code> type provides a single entry point for node-centric analyses. The <code>NodeView</code> wraps a reference to a workspace&#39;s graph and contains a node id. A <code>NodeView</code> gives you access to a node&#39;s underlying sequence, the nodes neighbouring nodes in the forward and backward directions, the reads mapped to a node, and kmer coverage over the node.</p><p>To get a <code>NodeView</code> of a node, use the <code>node</code> method on a <code>WorkSpace</code>, providing a node id number. A positive ID denotes a view of the node traversing it in the forward (canonical) direction. A negative ID denotes a view of the node, traversing it in the reverse complement direction.   </p><pre><code class="language-julia">julia&gt; n = node(ws, 3)
A view of a graph node (node: 3, graph: sdg):
  AAAAAACCTCCGCAACCCCATGTTTTCACATAACTGTTG…GCCATGACCGGCTGGCTGTCAGGCTGTCACTGATAATCA

</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../../api/Graphs/">Graphs submodule »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 July 2020 02:32">Monday 6 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
